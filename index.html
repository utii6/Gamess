<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Ø¹Ø¯Ù‘Ø§Ø¡ Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</title>
   <!-- Tailwind CSS CDN for styling -->
   <script src="https://cdn.tailwindcss.com"></script>
   <!-- three.js CDN for 3D rendering -->
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
   <!-- Telegram Web App SDK -->
   <script src="https://telegram.org/js/telegram-web-app.js"></script>
   <style>
       @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic:wght@400;700&display=swap');
       body {
           font-family: 'Noto Sans Arabic', sans-serif;
           overflow: hidden;
           touch-action: none; /* Disable default touch actions */
           background-color: #0d1117;
       }
       canvas {
           display: block;
       }
   </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-2">

   <div id="game-container" class="w-full max-w-lg shadow-2xl rounded-xl overflow-hidden bg-gray-800 flex flex-col">

       <!-- Score & Status Display -->
       <div class="p-3 bg-gray-700/70 backdrop-blur-sm flex justify-between items-center z-10">
           <h1 class="text-xl font-bold text-teal-400">ğŸƒâ€â™‚ï¸ Ø¹Ø¯Ø§Ø¡ Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… 3D</h1>
           <div class="flex space-x-4 space-x-reverse">
               <p id="score-display" class="text-lg font-mono bg-gray-900 px-3 py-1 rounded-full shadow-lg">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</p>
               <button id="start-button" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-1 px-4 rounded-full transition duration-300 shadow-md">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
           </div>
       </div>

       <!-- Canvas will be inserted here -->
       <div id="canvas-wrapper" class="relative w-full aspect-[4/5] bg-gray-900">
           <!-- Game Over Overlay -->
           <div id="game-over-modal" class="absolute inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center z-20 hidden rounded-b-xl transition duration-500">
               <div class="p-8 bg-gray-700 rounded-lg text-center shadow-2xl transform scale-95">
                   <p class="text-3xl font-extrabold text-red-500 mb-4">Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©!</p>
                   <p class="text-xl text-gray-200 mb-6">Ù†Ù‚Ø§Ø·Ùƒ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: <span id="final-score" class="text-yellow-400 font-mono font-bold">0</span></p>
                   <button onclick="startGame()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition duration-300 shadow-lg">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨</button>
                   <button onclick="closeApp()" class="mt-3 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg transition duration-300 shadow-lg">Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…</button>
               </div>
           </div>
       </div>
   </div>

   <!-- Instruction Box -->
   <div class="mt-4 p-3 bg-gray-700 rounded-xl w-full max-w-lg shadow-lg text-sm">
       <p class="font-bold mb-2 text-teal-300">Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù„Ø¹Ø¨:</p>
       <ul class="list-disc list-inside space-y-1 text-gray-300">
           <li><span class="font-semibold">Ø¹Ù„Ù‰ Ø§Ù„Ù‡Ø§ØªÙ:</span> Ø§Ø³Ø­Ø¨ Ù„Ù„ÙŠØ³Ø§Ø± Ø£Ùˆ Ù„Ù„ÙŠÙ…ÙŠÙ† Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø³Ø§Ø±. Ø§Ø³Ø­Ø¨ Ù„Ù„Ø£Ø¹Ù„Ù‰ Ù„Ù„Ù‚ÙØ².</li>
           <li><span class="font-semibold">Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø§Ø³ÙˆØ¨:</span> Ø§Ø³ØªØ®Ø¯Ù… Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ù‡Ù… (Ø§Ù„ÙŠØ³Ø§Ø±/Ø§Ù„ÙŠÙ…ÙŠÙ†) Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø³Ø§Ø±ØŒ ÙˆØ§Ù„Ø³Ù‡Ù… (Ø§Ù„Ø£Ø¹Ù„Ù‰) Ù„Ù„Ù‚ÙØ².</li>
       </ul>
   </div>


   <script>
       // --- Firebase/App ID Setup (Standard Canvas requirement) ---
       const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

       // --- Global three.js variables ---
       let scene, camera, renderer;
       let player;
       let clock = new THREE.Clock();
       let running = false;
       let score = 0;
       let speed = 0.05; // Base speed
       const LANE_WIDTH = 2;
       const LANES = [-LANE_WIDTH, 0, LANE_WIDTH]; // Left, Center, Right
       let currentLane = 1; // Start in center (index 1)
       
       // Player movement state
       let isJumping = false;
       let playerVelocityY = 0;
       const GRAVITY = -4; // Simple simulation of gravity

       // Obstacles array and properties
       const obstacles = [];
       let obstacleSpawnTimer = 0;
       const SPAWN_INTERVAL_BASE = 1.5; // seconds
       // Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø¹Ù‚Ø¨Ø§Øª: Ø£Ø­Ù…Ø±ØŒ Ø£ØµÙØ±ØŒ Ø³Ù…Ø§ÙˆÙŠØŒ Ø¨Ù†ÙØ³Ø¬ÙŠ
       const OBSTACLE_COLORS = [0xe53935, 0xffeb3b, 0x00bcd4, 0x9c27b0];
       
       const scoreDisplay = document.getElementById('score-display');
       const startButton = document.getElementById('start-button');
       const gameOverModal = document.getElementById('game-over-modal');

       // --- Telegram Web App Integration ---
       function initTelegram() {
           if (window.Telegram && window.Telegram.WebApp) {
               const WebApp = window.Telegram.WebApp;
               WebApp.ready();
               WebApp.setBackgroundColor('#0d1117'); // Set background to match
               WebApp.setHeaderColor('secondary_bg_color');

               WebApp.onEvent('mainButtonClicked', () => {
                   if (!running) {
                       startGame();
                   }
               });
           } else {
               console.warn("Telegram WebApp SDK not found. Running in standalone mode.");
           }
       }

       function closeApp() {
           if (window.Telegram && window.Telegram.WebApp) {
               const WebApp = window.Telegram.WebApp;
               // Send the final score back to the bot
               WebApp.sendData(`score:${score}`);
               WebApp.close();
           } else {
               window.location.reload(); // Simple refresh for standalone
           }
       }

       // --- Three.js Setup ---
       function initThree() {
           const container = document.getElementById('canvas-wrapper');
           const width = container.clientWidth;
           const height = container.clientHeight;

           // Scene
           scene = new THREE.Scene();
           scene.background = new THREE.Color(0x1a2a40); // Darker sky color

           // Camera (Perspective)
           camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 100);
           camera.position.set(0, 1.5, 5);
           camera.lookAt(0, 1, 0);

           // Renderer
           renderer = new THREE.WebGLRenderer({ antialias: true });
           renderer.setSize(width, height);
           container.appendChild(renderer.domElement);

           // Lighting
           const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
           scene.add(ambientLight);

           const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
           directionalLight.position.set(5, 5, 5);
           scene.add(directionalLight);

           // Ground/Road
           createRoad();
           
           // Player
           createPlayer();

           // Handle window resize
           window.addEventListener('resize', onWindowResize, false);
           onWindowResize(); // Initial call to size the canvas correctly

           // Start the game loop on window load (but pause state until start button)
           animate();
       }

       function onWindowResize() {
           const container = document.getElementById('canvas-wrapper');
           const width = container.clientWidth;
           const height = container.clientHeight;

           camera.aspect = width / height;
           camera.updateProjectionMatrix();
           renderer.setSize(width, height);
       }

       function createRoad() {
           const roadGeometry = new THREE.BoxGeometry(LANE_WIDTH * 3 + 0.2, 0.1, 1000); // Long road segment
           const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
           const road = new THREE.Mesh(roadGeometry, roadMaterial);
           road.position.set(0, 0, -450); // Position far away
           scene.add(road);
       }

       function createPlayer() {
           const playerGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
           const playerMaterial = new THREE.MeshPhongMaterial({ color: 0x4dd0e1 }); // Teal color
           player = new THREE.Mesh(playerGeometry, playerMaterial);
           player.position.set(LANES[currentLane], 0.9, 0);
           scene.add(player);
       }

       function createObstacle(laneIndex) {
           const height = 1.0 + Math.random() * 1.5; // Random height between 1.0 and 2.5
           const depth = 0.5;
           const obstacleGeometry = new THREE.BoxGeometry(0.8, height, depth);
           
           // Choose a random vibrant color
           const randomColor = OBSTACLE_COLORS[Math.floor(Math.random() * OBSTACLE_COLORS.length)];
           const obstacleMaterial = new THREE.MeshPhongMaterial({ color: randomColor });
           
           const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);

           // Position at the start of the track, in the chosen lane
           obstacle.position.set(LANES[laneIndex], height / 2, -100);
           obstacle.name = 'obstacle';
           scene.add(obstacle);
           obstacles.push(obstacle);
       }

       // --- Game Logic ---
       function resetGame() {
           score = 0;
           speed = 0.05;
           currentLane = 1;
           player.position.set(LANES[currentLane], 0.9, 0);
           isJumping = false;
           playerVelocityY = 0;

           // Clear existing obstacles
           obstacles.forEach(obstacle => scene.remove(obstacle));
           obstacles.length = 0;
           obstacleSpawnTimer = 0;
           updateScoreDisplay();
       }

       function startGame() {
           if (running) return;
           resetGame();
           running = true;
           clock.start();
           startButton.classList.add('hidden');
           gameOverModal.classList.add('hidden');
           
           // Focus on the document body to allow immediate keyboard control
           document.body.focus();
       }

       function gameOver() {
           running = false;
           startButton.classList.remove('hidden');
           gameOverModal.classList.remove('hidden');
           document.getElementById('final-score').textContent = Math.floor(score);
           
           // Optional: Haptic feedback for loss on Telegram
           if (window.Telegram && window.Telegram.WebApp) {
               window.Telegram.WebApp.HapticFeedback.notificationOccurred('error');
           }
       }

       function updateScoreDisplay() {
           scoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${Math.floor(score)}`;
       }

       function movePlayerToLane(newLaneIndex) {
           if (!running) return;
           currentLane = Math.max(0, Math.min(LANES.length - 1, newLaneIndex));
           
           // Simple visual animation for lane change (smooth movement)
           new TWEEN.Tween(player.position)
               .to({ x: LANES[currentLane] }, 150) // 150ms transition
               .easing(TWEEN.Easing.Quadratic.Out)
               .start();
           
           // Optional: Haptic feedback for lane change
           if (window.Telegram && window.Telegram.WebApp) {
               window.Telegram.WebApp.HapticFeedback.impactOccurred('light');
           }
       }

       function jump() {
           if (!running || isJumping) return;
           isJumping = true;
           playerVelocityY = 4; // Initial upward velocity

           // Optional: Haptic feedback for jump
           if (window.Telegram && window.Telegram.WebApp) {
               window.Telegram.WebApp.HapticFeedback.impactOccurred('medium');
           }
       }

       function updatePlayer(delta) {
           // Jumping (Y position)
           if (isJumping) {
               // Apply gravity/velocity
               playerVelocityY += GRAVITY * delta;
               player.position.y += playerVelocityY * delta;

               // Check for landing
               if (player.position.y <= 0.9) {
                   player.position.y = 0.9;
                   isJumping = false;
                   playerVelocityY = 0;
               }
           }
       }

       function updateObstacles(delta) {
           // Move obstacles towards the camera (Z-axis)
           const travelDistance = speed * delta * 60; // Scaling speed for smooth movement

           for (let i = obstacles.length - 1; i >= 0; i--) {
               const obstacle = obstacles[i];
               obstacle.position.z += travelDistance * 10; // Move towards camera

               // Check if obstacle is passed (passed Z=5)
               if (obstacle.position.z > 5) {
                   scene.remove(obstacle);
                   obstacles.splice(i, 1);
                   score += 10; // Score for passing an obstacle
               }
           }
       }

       function checkCollisions() {
           const playerBox = new THREE.Box3().setFromObject(player);
           
           for (const obstacle of obstacles) {
               const obstacleBox = new THREE.Box3().setFromObject(obstacle);
               
               // Simple collision check (AABB intersection)
               if (playerBox.intersectsBox(obstacleBox)) {
                   // Collision detected
                   gameOver();
                   break;
               }
           }
       }

       function spawnObstacles(delta) {
           obstacleSpawnTimer -= delta;

           if (obstacleSpawnTimer <= 0) {
               // Determine which lane(s) to spawn an obstacle in
               const laneToSpawn = Math.floor(Math.random() * 3); // 0, 1, or 2
               createObstacle(laneToSpawn);

               // Occasionally spawn a double obstacle (e.g., to force a jump or quick lane change)
               if (Math.random() < 0.25) {
                   let secondLane = (laneToSpawn + 1) % 3;
                   if (Math.random() < 0.5) secondLane = (laneToSpawn + 2) % 3;
                   
                   // Ensure the second lane is different
                   if (secondLane !== laneToSpawn) {
                        createObstacle(secondLane);
                   }
               }

               // Reset timer (faster spawning as speed increases)
               const interval = SPAWN_INTERVAL_BASE / (1 + speed * 10);
               obstacleSpawnTimer = interval;
           }
       }

       // --- Game Loop (Animate) ---
       function animate() {
           requestAnimationFrame(animate);

           if (running) {
               const delta = clock.getDelta();
               
               // Increase speed over time
               speed += delta * 0.005;
               score += delta * speed * 100;

               // Update game elements
               updatePlayer(delta);
               updateObstacles(delta);
               spawnObstacles(delta);
               checkCollisions();

               // Update UI
               updateScoreDisplay();
           }

           // Update TWEEN animations regardless of running state
           TWEEN.update();
           
           renderer.render(scene, camera);
       }

       // --- Input Handling (Touch and Keyboard) ---
       
       // Keyboard controls
       document.addEventListener('keydown', (e) => {
           if (!running) return;
           switch (e.key) {
               case 'ArrowLeft':
                   movePlayerToLane(currentLane - 1);
                   break;
               case 'ArrowRight':
                   movePlayerToLane(currentLane + 1);
                   break;
               case 'ArrowUp':
               case ' ': // Spacebar for convenience
                   jump();
                   break;
           }
       });

       // Touch/Swipe controls
       let touchstartX = 0;
       let touchstartY = 0;
       let touchendX = 0;
       let touchendY = 0;

       const handleGesture = () => {
           if (!running) return;

           const diffX = touchendX - touchstartX;
           const diffY = touchendY - touchstartY;

           if (Math.abs(diffX) > Math.abs(diffY)) {
               // Horizontal swipe (Lane change)
               if (Math.abs(diffX) > 30) { // minimum distance
                   if (diffX < 0) {
                       // Swipe left (move player to left lane)
                       movePlayerToLane(currentLane - 1);
                   } else {
                       // Swipe right (move player to right lane)
                       movePlayerToLane(currentLane + 1);
                   }
               }
           } else {
               // Vertical swipe (Jump)
               if (Math.abs(diffY) > 30) { // minimum distance
                   if (diffY < 0) {
                       // Swipe up
                       jump();
                   }
               }
           }
       };

       const gameContainer = document.getElementById('canvas-wrapper');

       gameContainer.addEventListener('touchstart', e => {
           touchstartX = e.changedTouches[0].screenX;
           touchstartY = e.changedTouches[0].screenY;
       }, false);

       gameContainer.addEventListener('touchend', e => {
           touchendX = e.changedTouches[0].screenX;
           touchendY = e.changedTouches[0].screenY;
           handleGesture();
       }, false);


       // --- Initialization ---
       window.onload = function() {
           // Load TWEEN.js for smooth animations (lane changes)
           const tweenScript = document.createElement('script');
           tweenScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.min.js';
           tweenScript.onload = () => {
               initTelegram();
               initThree();
           };
           document.head.appendChild(tweenScript);

           startButton.onclick = startGame;
       };

   </script>
</body>
</html>
